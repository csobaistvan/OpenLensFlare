#pragma once

#include "Dependencies.h"
#include "OpticalSystem.h"
#include "Ghost.h"

namespace OLEF
{
    
/// Enumerates a list of ghosts generated by an optical system that matches a 
/// certain criteria. It has its own class so that it can be pre-computed,
/// stored and used during parameter validataion and rendering.
class GhostList
{
public:
    /// Constructs an empty ghost list with no optical system or ghosts assigned.
    GhostList():
        m_opticalSystem(nullptr),
        m_maxBounces(0),
        m_apertureCross(0)
    {}

    /// Enumerates all the ghosts generated by an optical system that match
    /// the parameter filter values.
    /// The current implementation assumes that the system has exactly one
    /// aperture element and that the default enumeration parameters are used.
    GhostList(OpticalSystem* system, int maxBounces = 0, bool apertureCross = false):
        m_opticalSystem(system),
        m_maxBounces(maxBounces),
        m_apertureCross(apertureCross)
    {
        // Special treatment for the 'no reflections' case
        if (maxBounces == 0)
        {
            m_ghosts.push_back({});
            return;
        }

        // Index remapping when multiple aperture crossing is allowed
        std::vector<int> indexRemap;

        // Enumerate the apertures
        std::vector<int> interfaces;
        int totalInterfaces = 0;
        
        int prevId = -1;
        for (int i = 0; i < system->getElementCount(); ++i)
        {
            auto type = (*system)[i].getType();
            if (type == OpticalSystemElement::ElementType::APERTURE_STOP ||
                type == OpticalSystemElement::ElementType::SENSOR)
            {
                int numInterfaces = i - prevId - 1;

                interfaces.push_back(numInterfaces);
                totalInterfaces += numInterfaces;
                
                prevId = i;
            }
        }

        // If aperture crossing is allowed, then only use a single interface 
        // list, and we also need to populate the mapping
        if (apertureCross)
        {
            indexRemap.resize(totalInterfaces);
            
            int offset = 0;
            for (int i = 0; i < totalInterfaces; ++i)
            {
                while ((*system)[i + offset].getType() == OpticalSystemElement::ElementType::APERTURE_STOP)
                {
                    ++offset;
                }

                indexRemap[i] = i + offset;
            }

            interfaces = { totalInterfaces };
        }

        // Perform a preliminary counting step to reserve space in advance
        // for large reflection numbers
        if (maxBounces > 4)
        {
            int numGhosts = 0;
            generateGhosts(interfaces, maxBounces, [&](const auto& ghost)
            {
                ++numGhosts;
            });
            m_ghosts.reserve(numGhosts);
        }

        // Enumerate the ghosts.
        generateGhosts(interfaces, maxBounces, [this](const auto& ghost)
        {
            m_ghosts.push_back(ghost);
        });

        // The indices need to be remapped when aperture crossing is used.
        if (apertureCross)
        {
            for (auto& ghost: m_ghosts)
            {
                for (int i = 0; i < ghost.getLength(); ++i)
                {
                    ghost[i] = indexRemap[ghost[i]];
                }
            }
        }
    }

    /// Return the optical system used.
    OpticalSystem* getOpticalSystem() const { return m_opticalSystem; }

    /// Returns the maximum number of times a ray can be reflected.
    int getMaxBounces() const { return m_maxBounces; }
    
    /// Returns whether aperture crossing is allowed for ghost rays.
    bool getApertureCross() const { return m_apertureCross; }

    /// Returns the enumerated ghosts.
    const std::vector<Ghost>& getGhosts() const { return m_ghosts; }

    /// Returns the number of ghosts.
    size_t getGhostCount() const { return m_ghosts.size(); }

    /// Accesses the ith element of the list.
    Ghost& operator[](size_t i) { return m_ghosts[i]; }
    
    /// Accesses the ith element of the list.
    const Ghost& operator[](size_t i) const { return m_ghosts[i]; }

private:
    /// Generates all the ghosts that correspond to the parameter set of
    /// interfaces and reflection numbers.
    template<typename FnOut>
    void generateGhosts(const std::vector<int>& interfaces, int numReflections, FnOut output)
    {
        // Holds the indices for the current interface for each interface
        // that participates in the birth of the ghost
        std::vector<int> indices(numReflections);

        // Holds the current ghost interface indices
        std::vector<int> ghost(numReflections);

        // Interface offset, used to manage 'sub-regions' of the optical system
        // as separated by the apertures
        int offset = 0;

        // Process each region separately
        for (auto numInterfaces: interfaces)
        {
            // Init the indices for the current generation
            for (int i = 0; i < numReflections; ++i)
            {
                indices[i] = (i + 1) % 2;
            }

            // Enumerate each ghost
            while (indices[0] != numInterfaces)
            {
                // Generate the ghost indices
                for (int i = 0; i < numReflections; ++i)
                {
                    ghost[i] = offset + indices[i];
                }
                
                // Store the ghost
                output(ghost);
                
                // Increment each interface from back to front, until we reach
                // the first valid index, then note its position in the list
                int startIndex = numReflections;
                for (int i = numReflections - 1; i >= 0; --i, --startIndex)
                {
                    // Increment the index
                    indices[i] = indices[i] + 1;
                    
                    // First interfaces - these can go until the last element
                    if (i % 2 == 0 && (i == 0 || indices[i] < numInterfaces - 1))
                        break;
                    
                    // Second interfaces - thes can only go until the preceding
                    // interface index
                    if (i % 2 == 1 && (i == 0 || indices[i] < indices[i - 1]))
                        break;
                }
                
                // Re-initialize the indices that became invalid
                for (int i = startIndex; i < numReflections; ++i)
                {
                    // First interfaces - 
                    if (i % 2 == 0)
                    {
                        indices[i] = indices[i - 1] + 1;
                    }
                    
                    // Second interfaces - these start from the back
                    if (i % 2 == 1)
                    {
                        indices[i] = 0;
                    }
                }
            }
            
            // Increment the offset
            offset = offset + numInterfaces + 1;
        }
    }

    // The naive implementation, which only work for 2 bounces and no multiple
    // aperture crossing.
    template<typename FnOut>
    void generateGhostSimple(const std::vector<int>& interfaces, FnOut out)
    {
        // Count the number of elements before and after the aperture.
        int preApertureCount = (apertureIndex) * (apertureIndex - 1);
        int postApertureCount = (elementCount - apertureIndex - 1) * 
            (elementCount - apertureIndex - 2);

        // Enumerate the ghosts that are generated before the aperture
        for (int i = 0; i < apertureIndex; ++i)
        {
            for (int j = i + 1; j < apertureIndex; ++j)
            {
                out({ j, i });
            }
        }

        // Enumerate the ghosts that are generated after the aperture
        for (int i = apertureIndex + 1; i < elementCount; ++i)
        {
            for (int j = i + 1; j < elementCount; ++j)
            {
                out({ j, i });
            }
        }
    }

    /// The optical system that generates these ghosts.
    OpticalSystem* m_opticalSystem;

    /// The maximum number of times a ray can be reflected.
    int m_maxBounces;

    /// Whether the rays that correspond to a ghost may cross the aperture
    /// multiple times.
    bool m_apertureCross;

    /// The list of enumerated ghosts.
    std::vector<Ghost> m_ghosts;
};

}