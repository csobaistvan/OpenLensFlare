#pragma once

#include "Dependencies.h"
#include "OpticalSystem.h"
#include "Ghost.h"

namespace OLEF
{
    
/// Enumerates a list of ghosts generated by an optical system that matches a 
/// certain criteria. It has its own class so that it can be pre-computed,
/// stored and used during parameter validataion and rendering.
class GhostList
{
public:
    /// Constructs an empty ghost list, which coressponds to no optical system
    /// and contains no ghosts.
    GhostList():
        m_opticalSystem(nullptr),
        m_maxBounces(0),
        m_maxCrosses(0)
    {}

    /// Enumerates all the ghosts generated by an optical system that match
    /// the parameter filter values.
    /// The current implementation assumes that the system has exactly one
    /// aperture element and that the default enumeration parameters are used.
    GhostList(OpticalSystem* system, int maxBounces = 2, int maxCrosses = 1):
        m_opticalSystem(system),
        m_maxBounces(maxBounces),
        m_maxCrosses(maxCrosses)
    {
        // TODO: implement it more generally, and don't make the above assumptions.

        // Reference to the camera elements.
        const auto& elements = system->getElements();
        int elementCount = (int) elements.size();
        int apertureIndex = 0;

        // Find the aperture index
        for (int i = 0; i < elementCount; ++i)
        {
            if (elements[i].getType() == OpticalSystemElement::ElementType::APERTURE_STOP)
            {
                apertureIndex = i;
                break;
            }
        }

        // Count the number of elements before and after the aperture.
        int preApertureCount = (apertureIndex) * (apertureIndex - 1);
        int postApertureCount = (elementCount - apertureIndex - 1) * 
            (elementCount - apertureIndex - 2);

        // Reserve space in the container for all the ghosts.
        m_ghosts.reserve(preApertureCount + postApertureCount);

        // Enumerate the ghosts that are generated before the aperture
        for (int i = 0; i < apertureIndex; ++i)
        {
            for (int j = i + 1; j < apertureIndex; ++j)
            {
                m_ghosts.push_back({ j, i });
            }
        }

        // Enumerate the ghosts that are generated after the aperture
        for (int i = apertureIndex + 1; i < elementCount; ++i)
        {
            for (int j = i + 1; j < elementCount; ++j)
            {
                m_ghosts.push_back({ j, i });
            }
        }
    }

    /// Return the optical system used.
    OpticalSystem* getOpticalSystem() const { return m_opticalSystem; }

    /// Returns the maximum number of times a ray can be reflected.
    int getMaxBounces() const { return m_maxBounces; }
    
    /// Returns the maximum number of times a ray can cross an aperture.
    int getMaxCrosses() const { return m_maxCrosses; }

    /// Returns the enumerated ghosts.
    const std::vector<Ghost>& getGhosts() const { return m_ghosts; }

    /// Returns the number of ghosts.
    size_t getGhostCount() const { return m_ghosts.size(); }

    /// Accesses the ith element of the list.
    Ghost& operator[](size_t i) { return m_ghosts[i]; }
    
    /// Accesses the ith element of the list.
    const Ghost& operator[](size_t i) const { return m_ghosts[i]; }

private:
    /// The optical system that generates these ghosts.
    OpticalSystem* m_opticalSystem;

    /// The maximum number of times a ray can be reflected.
    int m_maxBounces;

    /// The maximum number of times a ray can cross an aperture.
    int m_maxCrosses;

    /// The list of enumerated ghosts.
    std::vector<Ghost> m_ghosts;
};

}